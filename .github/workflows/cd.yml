name: Continuous Deployment

on:
  workflow_run:
    workflows:
      - Continuous Integration
      - Security Scans
      - Package Validation
    types:
      - completed
    branches:
      - main
      - dev
  workflow_dispatch:

concurrency:
  group: cd-${{ github.event.workflow_run.head_branch || github.ref_name }}-${{ github.event.workflow_run.head_sha || github.sha }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}

jobs:
  gate-dependencies:
    name: Verify Upstream Workflow Dependencies
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read

    outputs:
      branch: ${{ steps.dependency_gate.outputs.branch }}
      target_sha: ${{ steps.dependency_gate.outputs.target_sha }}

    steps:
      - name: Wait for required workflows on this commit
        id: dependency_gate
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const required = ['Continuous Integration', 'Security Scans', 'Package Validation'];
            const eventName = context.eventName;

            if (eventName === 'workflow_dispatch') {
              const branch = context.ref.replace('refs/heads/', '');
              core.setOutput('branch', branch);
              core.setOutput('target_sha', context.sha);
              core.info(`Manual dispatch detected; using branch=${branch}, sha=${context.sha.substring(0, 8)}`);
              return;
            }

            const triggeringRun = context.payload.workflow_run;
            const branch = triggeringRun?.head_branch;
            const sha = triggeringRun?.head_sha;
            const sourceEvent = triggeringRun?.event;

            if (!branch || !sha) {
              core.setFailed('Missing workflow_run head branch/SHA context for dependency gating.');
              return;
            }

            if (sourceEvent !== 'push') {
              core.setFailed(`CD only supports push events, got: ${sourceEvent || 'unknown'}`);
              return;
            }

            core.setOutput('branch', branch);
            core.setOutput('target_sha', sha);

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
            const timeoutMs = 20 * 60 * 1000;
            const intervalMs = 20 * 1000;
            const start = Date.now();

            while (true) {
              const { data } = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                head_sha: sha,
                per_page: 100,
              });

              const byName = new Map();
              for (const run of data.workflow_runs) {
                if (!byName.has(run.name)) {
                  byName.set(run.name, run);
                }
              }

              const missing = [];
              const pending = [];
              const failed = [];

              for (const name of required) {
                const run = byName.get(name);
                if (!run) {
                  missing.push(name);
                  continue;
                }

                if (run.status !== 'completed') {
                  pending.push(`${name} (${run.status})`);
                  continue;
                }

                if (run.conclusion !== 'success') {
                  failed.push(`${name} (${run.conclusion})`);
                }
              }

              core.info(`Required workflows for ${sha.substring(0, 8)}:`);
              core.info(`- missing: ${missing.length ? missing.join(', ') : 'none'}`);
              core.info(`- pending: ${pending.length ? pending.join(', ') : 'none'}`);
              core.info(`- failed: ${failed.length ? failed.join(', ') : 'none'}`);

              if (failed.length) {
                core.setFailed(`Blocking CD because upstream workflow(s) failed: ${failed.join(', ')}`);
                return;
              }

              if (!missing.length && !pending.length) {
                core.info('All required upstream workflows succeeded.');
                return;
              }

              if (Date.now() - start > timeoutMs) {
                core.setFailed(`Timed out waiting for upstream workflows. Missing: ${missing.join(', ') || 'none'}; Pending: ${pending.join(', ') || 'none'}`);
                return;
              }

              await sleep(intervalMs);
            }

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: gate-dependencies
    if: ${{ needs.gate-dependencies.result == 'success' }}

    permissions:
      contents: read
      packages: write

    outputs:
      image_repo: ${{ steps.vars.outputs.image_repo }}
      image_tag: ${{ steps.vars.outputs.image_tag }}
      image_digest: ${{ steps.build.outputs.digest }}
      short_sha: ${{ steps.vars.outputs.short_sha }}
      project_version: ${{ steps.versions.outputs.project_version }}
      package_version: ${{ steps.versions.outputs.package_version }}

    steps:
      - name: Notify CD Start
        uses: actions/github-script@v8
        if: always()
        with:
          script: |
            if (!process.env.SLACK_WEBHOOK) {
              core.info('SLACK_WEBHOOK is not set; skipping Slack notification.');
              return;
            }
            try {
              await fetch(process.env.SLACK_WEBHOOK, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  text: 'üöÄ Continuous Delivery - Build Started',
                  blocks: [{
                    type: 'section',
                    text: {
                      type: 'mrkdwn',
                      text: `*üöÄ CD Pipeline Started*\n*Building Docker image + updating GitOps manifests*\n*Branch:* ${process.env.BRANCH}`
                    }
                  }]
                })
              });
            } catch (e) {
              core.warning('Slack notification failed: ' + e.message);
            }
        env:
          SLACK_WEBHOOK: ${{ env.SLACK_WEBHOOK }}
          BRANCH: ${{ needs.gate-dependencies.outputs.branch }}

      - name: Checkout code at CI commit
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ needs.gate-dependencies.outputs.target_sha }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract and validate versions
        id: versions
        shell: bash
        run: |
          set -euo pipefail
          PROJECT_VERSION=$(grep -m 1 '^version = ' pyproject.toml | sed 's/version = "//;s/".*//')
          PACKAGE_VERSION=$(grep -m 1 '^version = ' packages/dataenginex/pyproject.toml | sed 's/version = "//;s/".*//')

          if [[ -z "$PROJECT_VERSION" || -z "$PACKAGE_VERSION" ]]; then
            echo "Missing version in pyproject files."
            exit 1
          fi

          SEMVER_REGEX='^[0-9]+\.[0-9]+\.[0-9]+([.-][0-9A-Za-z.-]+)?$'
          if [[ ! "$PROJECT_VERSION" =~ $SEMVER_REGEX ]]; then
            echo "Root project version is not semver-compatible: $PROJECT_VERSION"
            exit 1
          fi
          if [[ ! "$PACKAGE_VERSION" =~ $SEMVER_REGEX ]]; then
            echo "DataEngineX package version is not semver-compatible: $PACKAGE_VERSION"
            exit 1
          fi

          echo "project_version=$PROJECT_VERSION" >> "$GITHUB_OUTPUT"
          echo "package_version=$PACKAGE_VERSION" >> "$GITHUB_OUTPUT"

      - name: Extract commit SHA and image tags
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          SHORT_SHA=$(git rev-parse --short=8 HEAD)
          OWNER_LOWER=$(echo "${REPO_OWNER}" | tr '[:upper:]' '[:lower:]')
          IMAGE_REPO="${REGISTRY}/${OWNER_LOWER}/dex"
          SHA_TAG="sha-${SHORT_SHA}"

          {
            echo "owner_lower=${OWNER_LOWER}"
            echo "short_sha=$SHORT_SHA"
            echo "image_repo=${IMAGE_REPO}"
            echo "image_tag=${IMAGE_REPO}:${SHA_TAG}"
            echo "sha_tag=${SHA_TAG}"
          } >> "$GITHUB_OUTPUT"
        env:
          REGISTRY: ${{ env.REGISTRY }}
          REPO_OWNER: ${{ github.repository_owner }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.vars.outputs.image_repo }}
          tags: |
            type=raw,value=${{ steps.vars.outputs.sha_tag }}
            type=raw,value=v${{ steps.versions.outputs.project_version }},enable=${{ needs.gate-dependencies.outputs.branch == 'main' }}
            type=raw,value=latest,enable=${{ needs.gate-dependencies.outputs.branch == 'main' }}
            type=raw,value=dev,enable=${{ needs.gate-dependencies.outputs.branch == 'dev' }}

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
          sbom: true
          provenance: true

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build-and-push
    if: ${{ needs.build-and-push.result == 'success' }}

    permissions:
      packages: read
      security-events: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull and list image from GHCR
        shell: bash
        run: |
          set -euo pipefail
          echo "Pulling image: ${{ needs.build-and-push.outputs.image_tag }}"
          docker pull "${{ needs.build-and-push.outputs.image_tag }}"
          docker images | grep dex || true

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.34.1
        with:
          image-ref: ${{ needs.build-and-push.outputs.image_tag }}
          format: sarif
          output: trivy-results.sarif

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: trivy-results.sarif

  update-gitops-manifests:
    name: Update GitOps Manifests
    runs-on: ubuntu-latest
    needs: [gate-dependencies, build-and-push, security-scan]
    if: ${{ needs.build-and-push.result == 'success' && needs.security-scan.result == 'success' }}

    permissions:
      contents: write
      pull-requests: write
      issues: write

    outputs:
      updated: ${{ steps.commit.outputs.updated }}
      update_mode: ${{ steps.commit.outputs.update_mode }}

    steps:
      - name: Checkout branch
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ needs.gate-dependencies.outputs.branch }}
          token: ${{ secrets.GITOPS_BOT_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Update overlay image tags
        id: update
        shell: bash
        env:
          BRANCH: ${{ needs.gate-dependencies.outputs.branch }}
          NEW_TAG: sha-${{ needs.build-and-push.outputs.short_sha }}
        run: |
          set -euo pipefail
          files=()
          if [[ "$BRANCH" == "dev" ]]; then
            files=("infra/argocd/overlays/dev/kustomization.yaml")
          elif [[ "$BRANCH" == "main" ]]; then
            files=(
              "infra/argocd/overlays/prod/kustomization.yaml"
            )
          else
            echo "Unsupported branch for deployment: $BRANCH"
            exit 1
          fi

          for file in "${files[@]}"; do
            echo "Updating $file -> $NEW_TAG"
            sed -i -E "s|(newTag:[[:space:]]*).*|\\1${NEW_TAG}|" "$file"
          done

      - name: Commit and push manifest updates
        id: commit
        shell: bash
        env:
          BRANCH: ${{ needs.gate-dependencies.outputs.branch }}
          NEW_TAG: sha-${{ needs.build-and-push.outputs.short_sha }}
          GH_TOKEN: ${{ secrets.GITOPS_BOT_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [[ -z "$(git status --porcelain infra/argocd/overlays)" ]]; then
            echo "No manifest changes detected."
            echo "updated=false" >> "$GITHUB_OUTPUT"
            echo "update_mode=no_changes" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add infra/argocd/overlays
          git commit -m "chore: update ${BRANCH} image to ${NEW_TAG} [skip ci]"

          if git push origin "HEAD:${BRANCH}"; then
            echo "Pushed manifest update directly to ${BRANCH}."
            echo "updated=true" >> "$GITHUB_OUTPUT"
            echo "update_mode=direct_push" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Direct push to ${BRANCH} was rejected (likely branch protection). Creating pull request instead."
          PR_BRANCH="bot/gitops-${BRANCH}-${NEW_TAG}-${GITHUB_RUN_ID}"
          git checkout -b "$PR_BRANCH"
          git push origin "HEAD:${PR_BRANCH}"

          PR_BODY=$(printf "Automated GitOps manifest update from CD pipeline.\n\n- Branch: %s\n- Image tag: %s\n- Source run: %s/%s/actions/runs/%s" \
            "$BRANCH" "$NEW_TAG" "$GITHUB_SERVER_URL" "$GITHUB_REPOSITORY" "$GITHUB_RUN_ID")

          if gh pr create \
            --base "$BRANCH" \
            --head "$PR_BRANCH" \
            --title "chore: update ${BRANCH} image to ${NEW_TAG}" \
            --body "$PR_BODY"; then
            echo "Opened PR branch ${PR_BRANCH}; deployment verification is skipped until PR is merged."
            echo "updated=false" >> "$GITHUB_OUTPUT"
            echo "update_mode=pr_opened" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "GitHub Actions is not permitted to create pull requests in this repository. Opening issue instead."
          ISSUE_BODY=$(printf "Automated GitOps update could not be pushed directly to protected branch \`%s\` and this workflow token cannot create PRs.\n\nCreated branch: \`%s\`\n\nCreate PR manually:\n- Base: \`%s\`\n- Head: \`%s\`\n\nWorkflow run: %s/%s/actions/runs/%s" \
            "$BRANCH" "$PR_BRANCH" "$BRANCH" "$PR_BRANCH" "$GITHUB_SERVER_URL" "$GITHUB_REPOSITORY" "$GITHUB_RUN_ID")

          gh issue create \
            --title "[CD action required] Promote ${NEW_TAG} to ${BRANCH}" \
            --body "$ISSUE_BODY" \
            --label deployment

          echo "updated=false" >> "$GITHUB_OUTPUT"
          echo "update_mode=issue_opened" >> "$GITHUB_OUTPUT"
          echo "Created issue for manual PR creation from ${PR_BRANCH}."
          exit 0

  verify-deployment:
    name: Verify ArgoCD Deployment Health
    runs-on: ubuntu-latest
    needs: [gate-dependencies, update-gitops-manifests]
    if: ${{ needs.update-gitops-manifests.result == 'success' && needs.update-gitops-manifests.outputs.updated == 'true' }}

    outputs:
      verification_enabled: ${{ steps.plan.outputs.verification_enabled }}

    steps:
      - name: Plan verification targets
        id: plan
        shell: bash
        env:
          BRANCH: ${{ needs.gate-dependencies.outputs.branch }}
          ARGOCD_SERVER: ${{ vars.ARGOCD_SERVER }}
          ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
        run: |
          set -euo pipefail
          if [[ "$BRANCH" == "dev" ]]; then
            echo "apps=dex-dev" >> "$GITHUB_OUTPUT"
          elif [[ "$BRANCH" == "main" ]]; then
            echo "apps=dex" >> "$GITHUB_OUTPUT"
          else
            echo "Unsupported branch for verification: $BRANCH"
            exit 1
          fi

          if [[ -n "$ARGOCD_SERVER" && -n "$ARGOCD_AUTH_TOKEN" ]]; then
            echo "verification_enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "verification_enabled=false" >> "$GITHUB_OUTPUT"
            echo "ArgoCD variables/secrets missing; skipping deployment health verification."
          fi

      - name: Install ArgoCD CLI
        if: ${{ steps.plan.outputs.verification_enabled == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          VERSION="v2.14.13"
          curl -sSL -o argocd "https://github.com/argoproj/argo-cd/releases/download/${VERSION}/argocd-linux-amd64"
          install -m 555 argocd /usr/local/bin/argocd
          argocd version --client

      - name: Wait for ArgoCD apps to become healthy
        if: ${{ steps.plan.outputs.verification_enabled == 'true' }}
        shell: bash
        env:
          APPS: ${{ steps.plan.outputs.apps }}
          ARGOCD_SERVER: ${{ vars.ARGOCD_SERVER }}
          ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
        run: |
          set -euo pipefail
          for app in $APPS; do
            echo "Waiting for ArgoCD app: $app"
            argocd app wait "$app" \
              --server "$ARGOCD_SERVER" \
              --auth-token "$ARGOCD_AUTH_TOKEN" \
              --grpc-web \
              --insecure \
              --sync \
              --health \
              --timeout 600
          done

      - name: Run optional post-deploy smoke checks
        if: ${{ steps.plan.outputs.verification_enabled == 'true' }}
        shell: bash
        env:
          BRANCH: ${{ needs.gate-dependencies.outputs.branch }}
          DEV_HEALTHCHECK_URL: ${{ vars.DEV_HEALTHCHECK_URL }}
          PROD_HEALTHCHECK_URL: ${{ vars.PROD_HEALTHCHECK_URL }}
        run: |
          set -euo pipefail

          urls=()
          if [[ "$BRANCH" == "dev" ]]; then
            [[ -n "${DEV_HEALTHCHECK_URL}" ]] && urls+=("${DEV_HEALTHCHECK_URL}")
          elif [[ "$BRANCH" == "main" ]]; then
            [[ -n "${PROD_HEALTHCHECK_URL}" ]] && urls+=("${PROD_HEALTHCHECK_URL}")
          fi

          if [[ ${#urls[@]} -eq 0 ]]; then
            echo "No healthcheck URLs configured; skipping smoke checks."
            exit 0
          fi

          for url in "${urls[@]}"; do
            echo "Running smoke check against ${url}"
            code=$(curl -sS -o /dev/null -w "%{http_code}" --max-time 15 --retry 3 --retry-delay 2 "$url")
            if [[ "$code" != "200" ]]; then
              echo "Smoke check failed for ${url} with status ${code}"
              exit 1
            fi
          done

  rollback-gitops:
    name: Rollback GitOps Manifest Update
    runs-on: ubuntu-latest
    needs: [gate-dependencies, build-and-push, update-gitops-manifests, verify-deployment]
    if: ${{ always() && needs.update-gitops-manifests.outputs.updated == 'true' && needs.verify-deployment.result == 'failure' }}

    permissions:
      contents: write

    steps:
      - name: Checkout deployment branch
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ needs.gate-dependencies.outputs.branch }}
          token: ${{ secrets.GITOPS_BOT_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Revert manifest commit
        shell: bash
        env:
          BRANCH: ${{ needs.gate-dependencies.outputs.branch }}
          NEW_TAG: sha-${{ needs.build-and-push.outputs.short_sha }}
        run: |
          set -euo pipefail

          TARGET_SHA=$(git log --format='%H %s' -n 30 -- infra/argocd/overlays \
            | grep -F "chore: update ${BRANCH} image to ${NEW_TAG} [skip ci]" \
            | head -n 1 \
            | cut -d' ' -f1)

          if [[ -z "$TARGET_SHA" ]]; then
            echo "Unable to locate manifest update commit for rollback."
            exit 1
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git revert --no-commit "$TARGET_SHA"
          git commit -m "fix: rollback ${BRANCH} image after failed ArgoCD verification [skip ci]"
          git push origin "HEAD:${BRANCH}"

  create-rollback-issue:
    name: Create Rollback Incident Issue
    runs-on: ubuntu-latest
    needs: [gate-dependencies, build-and-push, verify-deployment, rollback-gitops]
    if: ${{ always() && needs.verify-deployment.result == 'failure' }}

    permissions:
      contents: read
      issues: write

    steps:
      - name: Create incident issue
        uses: actions/github-script@v8
        with:
          script: |
            const rollbackResult = process.env.ROLLBACK_RESULT || 'unknown';
            const branch = process.env.BRANCH;
            const imageTag = process.env.IMAGE_TAG;
            const runUrl = process.env.RUN_URL;
            const actor = process.env.ACTOR;

            const title = `[CD Incident] Deployment verification failed on ${branch} (${imageTag})`;
            const body = [
              '## CD deployment verification failed',
              '',
              `- Branch: ${branch}`,
              `- Image: ${imageTag}`,
              `- Rollback job result: ${rollbackResult}`,
              `- Triggered by: ${actor}`,
              `- Workflow run: ${runUrl}`,
              '',
              '### Required follow-up',
              '- [ ] Review ArgoCD app health and sync status',
              '- [ ] Validate Kubernetes pod readiness and logs',
              '- [ ] Confirm rollback image/tag state in overlays',
              '- [ ] Add root cause and remediation notes',
            ].join('\n');

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body,
              labels: ['incident', 'cd', 'deployment'],
            });
        env:
          ROLLBACK_RESULT: ${{ needs.rollback-gitops.result }}
          BRANCH: ${{ needs.gate-dependencies.outputs.branch }}
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          ACTOR: ${{ github.actor }}


  notify-deployment:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [gate-dependencies, build-and-push, security-scan, update-gitops-manifests, verify-deployment, rollback-gitops, create-rollback-issue]
    if: always()

    steps:
      - name: Notify CD Success
        if: ${{ needs.build-and-push.result == 'success' && needs.security-scan.result == 'success' && needs.update-gitops-manifests.result == 'success' && needs.update-gitops-manifests.outputs.update_mode != 'pr_opened' && needs.update-gitops-manifests.outputs.update_mode != 'issue_opened' && (needs.verify-deployment.result == 'success' || needs.verify-deployment.result == 'skipped') }}
        uses: actions/github-script@v8
        with:
          script: |
            if (!process.env.SLACK_WEBHOOK) {
              core.info('SLACK_WEBHOOK is not set; skipping Slack notification.');
              return;
            }
            try {
              await fetch(process.env.SLACK_WEBHOOK, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  text: '‚úÖ Deployment Succeeded',
                  blocks: [
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: `*‚úÖ Continuous Delivery Completed*\n*Docker image built and GitOps manifests updated*`
                      }
                    },
                    {
                      type: 'section',
                      fields: [
                        { type: 'mrkdwn', text: `*Image:*\n${process.env.TAG}` },
                        { type: 'mrkdwn', text: `*Branch:*\n${process.env.BRANCH}` },
                        { type: 'mrkdwn', text: `*Project Version:*\n${process.env.PROJECT_VERSION}` },
                        { type: 'mrkdwn', text: `*DataEngineX Version:*\n${process.env.PACKAGE_VERSION}` },
                        { type: 'mrkdwn', text: `*Verification:*\n${process.env.VERIFICATION_RESULT}` },
                        { type: 'mrkdwn', text: `*Run:*\n<${process.env.URL}|View Details>` }
                      ]
                    }
                  ]
                })
              });
            } catch (e) {
              core.warning('Slack notification failed: ' + e.message);
            }
        env:
          SLACK_WEBHOOK: ${{ env.SLACK_WEBHOOK }}
          TAG: ${{ needs.build-and-push.outputs.image_tag }}
          BRANCH: ${{ needs.gate-dependencies.outputs.branch }}
          PROJECT_VERSION: ${{ needs.build-and-push.outputs.project_version }}
          PACKAGE_VERSION: ${{ needs.build-and-push.outputs.package_version }}
          VERIFICATION_RESULT: ${{ needs.verify-deployment.result }}
          URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      - name: Notify CD Pending Manual Promotion
        if: ${{ needs.build-and-push.result == 'success' && needs.security-scan.result == 'success' && needs.update-gitops-manifests.result == 'success' && (needs.update-gitops-manifests.outputs.update_mode == 'pr_opened' || needs.update-gitops-manifests.outputs.update_mode == 'issue_opened') }}
        uses: actions/github-script@v8
        with:
          script: |
            if (!process.env.SLACK_WEBHOOK) {
              core.info('SLACK_WEBHOOK is not set; skipping Slack notification.');
              return;
            }
            try {
              await fetch(process.env.SLACK_WEBHOOK, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  text: '‚è≥ CD awaiting protected-branch approval',
                  blocks: [
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: `*‚è≥ CD requires manual approval path*\n*Manifest update was not pushed directly due to branch protection*`
                      }
                    },
                    {
                      type: 'section',
                      fields: [
                        { type: 'mrkdwn', text: `*Image:*\n${process.env.TAG}` },
                        { type: 'mrkdwn', text: `*Branch:*\n${process.env.BRANCH}` },
                        { type: 'mrkdwn', text: `*Update mode:*\n${process.env.UPDATE_MODE}` },
                        { type: 'mrkdwn', text: `*Run:*\n<${process.env.URL}|View Details>` }
                      ]
                    }
                  ]
                })
              });
            } catch (e) {
              core.warning('Slack notification failed: ' + e.message);
            }
        env:
          SLACK_WEBHOOK: ${{ env.SLACK_WEBHOOK }}
          TAG: ${{ needs.build-and-push.outputs.image_tag }}
          BRANCH: ${{ needs.gate-dependencies.outputs.branch }}
          UPDATE_MODE: ${{ needs.update-gitops-manifests.outputs.update_mode }}
          URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      - name: Notify CD Failure
        if: ${{ needs.build-and-push.result == 'failure' || needs.security-scan.result == 'failure' || needs.update-gitops-manifests.result == 'failure' || needs.verify-deployment.result == 'failure' || needs.rollback-gitops.result == 'failure' || needs.create-rollback-issue.result == 'failure' }}
        uses: actions/github-script@v8
        with:
          script: |
            if (!process.env.SLACK_WEBHOOK) {
              core.info('SLACK_WEBHOOK is not set; skipping Slack notification.');
              return;
            }
            const buildResult = process.env.BUILD_RESULT;
            const scanResult = process.env.SCAN_RESULT;
            const gitopsResult = process.env.GITOPS_RESULT;
            const verifyResult = process.env.VERIFY_RESULT;
            const rollbackResult = process.env.ROLLBACK_RESULT;
            const issueResult = process.env.ISSUE_RESULT;
            const failedJobs = [];
            if (buildResult === 'failure') failedJobs.push('Docker Build');
            if (scanResult === 'failure') failedJobs.push('Security Scan');
            if (gitopsResult === 'failure') failedJobs.push('GitOps Update');
            if (verifyResult === 'failure') failedJobs.push('Deployment Verification');
            if (rollbackResult === 'failure') failedJobs.push('Rollback');
            if (issueResult === 'failure') failedJobs.push('Incident Issue Creation');
            try {
              await fetch(process.env.SLACK_WEBHOOK, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  text: '‚ùå CD Pipeline Failed',
                  blocks: [
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: `*‚ùå CD Pipeline Failed*`
                      }
                    },
                    {
                      type: 'section',
                      fields: [
                        { type: 'mrkdwn', text: `*Failed Jobs:*\n${failedJobs.join(', ') || 'Unknown'}` },
                        { type: 'mrkdwn', text: `*Branch:*\n${process.env.BRANCH}` },
                        { type: 'mrkdwn', text: `*Triggered by:*\n${process.env.ACTOR}` },
                        { type: 'mrkdwn', text: `*Rollback:*\n${rollbackResult}` },
                        { type: 'mrkdwn', text: `*Run:*\n<${process.env.URL}|View Details>` }
                      ]
                    }
                  ]
                })
              });
            } catch (e) {
              core.warning('Slack notification failed: ' + e.message);
            }
        env:
          SLACK_WEBHOOK: ${{ env.SLACK_WEBHOOK }}
          BUILD_RESULT: ${{ needs.build-and-push.result }}
          SCAN_RESULT: ${{ needs.security-scan.result }}
          GITOPS_RESULT: ${{ needs.update-gitops-manifests.result }}
          VERIFY_RESULT: ${{ needs.verify-deployment.result }}
          ROLLBACK_RESULT: ${{ needs.rollback-gitops.result }}
          ISSUE_RESULT: ${{ needs.create-rollback-issue.result }}
          BRANCH: ${{ needs.gate-dependencies.outputs.branch }}
          ACTOR: ${{ github.actor }}
          URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
